# Exotically Sized Types(Rust 里的“奇葩”类型)
Rust 里面一些“不走寻常路”的类型，它们的大小不像咱们平时想的那样，是个固定的正数。主要有三种：

1.  **动态大小类型 (Dynamically Sized Types - DSTs)**
    *   **啥意思？** 就是说，这种类型在写代码的时候（编译时），我们不知道它到底有多大。
    *   **这不就怪了吗？** Rust 必须知道大小才能处理数据啊！没错，所以 DSTs 不是“普通”类型。它们不能直接放在栈上或者作为结构体的普通成员（除非是最后一个成员，并且这会让整个结构体也变成 DST）。
    *   **咋用？** 它们只能通过“指针”来使用。而且这种指针是“胖指针”（wide pointer），除了指向数据的地址外，还带了额外的信息来“补全”这个 DST。
    *   **常见的 DSTs 有两种：**
        *   **Trait 对象 (Trait objects): `dyn MyTrait`**
            *   代表某个实现了 `MyTrait` 这个接口的类型，但具体是哪个类型，编译时不知道，运行时才知道。
            *   “胖指针”里的额外信息是：一个指向“虚函数表 (vtable)”的指针。这个表里存着调用这个具体类型的方法所需要的所有信息。运行时可以通过 vtable 查询到它实际占多大地方。
        *   **切片 (Slices): `[T]`, `str` 等**
            *   就是对一块连续内存（比如数组或 `Vec`）的一个“视图”或“引用”。
            *   “胖指针”里的额外信息是：切片里有多少个元素。
            *   运行时它的大小就是 “单个元素的大小” 乘以 “元素数量”。
    *   **自定义 DSTs：**
        *   你可以在结构体的最后一个字段放一个 DST，比如 `struct MySuperSlice { info: u32, data: [u8] }`。但这样一来，`MySuperSlice` 自己也变成了一个 DST。
        *   目前创建自定义 DST 的正经方法有点绕，通常是先定义一个泛型结构体，然后通过“不定长转换 (unsizing coercion)”来实现。
            ```rust
            struct MySuperSliceable<T: ?Sized> { // ?Sized 表示 T 可以是 DST
                info: u32,
                data: T,
            }

            fn main() {
                let sized: MySuperSliceable<[u8; 8]> = MySuperSliceable { // 这是个固定大小的
                    info: 17,
                    data: [0; 8],
                };

                // 把固定大小的转成动态大小的引用
                let dynamic: &MySuperSliceable<[u8]> = &sized;
                // dynamic 现在是个胖指针，包含了 data 的长度信息
            }
            ```
        *   作者也说了，自定义 DST 现在还是个“半成品”功能。

2.  **零大小类型 (Zero Sized Types - ZSTs)**
    *   **啥意思？** 就是这种类型不占任何内存空间，大小是 0。
    *   **例子：**
        *   `struct Nothing;` (没有字段的结构体)
        *   `struct LotsOfNothing { foo: Nothing, qux: (), baz: [u8; 0] }` (所有字段都是 ZST，那它自己也是 ZST。`()`是空元组，`[u8; 0]`是空数组，都是 ZST)
    *   **有啥用？** 单独看，ZST 好像没啥用。但它在**泛型编程**里特别牛逼！
        *   Rust 编译器很聪明，它知道任何产生、存储 ZST 的操作都可以直接忽略掉（变成空操作 no-op）。存它没意义（不占地方），取它也没意义（反正就那一个“值”，而且也不占地方）。
    *   **经典例子：`Set` (集合) 的实现**
        *   通常 `Set<Key>` (存一堆不重复的 Key) 可以用 `Map<Key, Value>` (键值对) 来实现，只要把 `Value` 设成一个没用的占位符就行。
        *   在其他语言里，这个“没用的占位符”可能也得占点空间，也得费点劲去存取。
        *   但在 Rust 里，你可以写 `Set<Key> = Map<Key, ()>`。这里的 `()` (空元组) 就是个 ZST。
        *   Rust 编译器一看，哦，值是 `()`，那所有存取值的操作都省了，分配空间也省了。结果就是，用 `HashMap<Key, ()>` 实现的 `HashSet<Key>` 几乎没有存储“值”的开销，非常高效！
    *   **`unsafe` 代码要注意：**
        *   虽然安全代码不用太操心 ZST，但写 `unsafe` 代码时要小心。比如，对指向 ZST 的指针做偏移操作是无效的（因为大小是0，移了等于没移）。内存分配器通常也要求分配的大小不能是0。
        *   **重要：** 对 ZST 的引用（包括空切片的引用）也必须是**非空 (non-null)** 且**正确对齐**的。解引用一个空的或未对齐的指向 ZST 的指针，照样是未定义行为！

3.  **空类型 (Empty Types)**
    *   **啥意思？** 这种类型甚至**不能被创建出任何实例**（值）。它只能在“类型层面”讨论，不能在“值层面”使用。
    *   **怎么定义？** 用一个没有任何变体（variant）的枚举：
        ```rust
        enum Void {} // 没有变体，所以是空类型
        ```
    *   **有啥用？** 比 ZST 更小众。主要用来在**类型层面表示“不可能发生”或“不可达”**。
    *   **例子：绝对不会出错的 `Result`**
        *   假设一个函数通常返回 `Result<T, ErrorType>`，但在某个特定情况下，它保证永远不会出错。
        *   你可以让它返回 `Result<T, Void>`。这样，使用者一看返回类型就知道，这个 `Result` 绝对不可能是 `Err(Void)`，因为你根本造不出一个 `Void` 类型的值来！所以可以直接、放心地 `unwrap()`。
    *   **优化：** Rust 理论上可以优化 `Result<T, Void>`，让它在内存中就只表示成 `T`，因为 `Err` 的情况不存在。但这只是个优化，不是保证。
    *   **可以这样写：**
        ```rust
        enum Void {}
        let res: Result<u32, Void> = Ok(0);
        let Ok(num) = res; // 因为 Err(Void) 不可能，所以 Ok(num) 匹配必然成功
        ```
    *   **注意：** 虽然不能创建空类型的值，但你可以创建指向空类型的**裸指针 (raw pointer)**，比如 `*const Void`。但是！**解引用这个指针是未定义行为**，因为那没意义。
    *   **不推荐用 `*const Void` 来模拟 C 语言的 `void*`：**
        *   很多人尝试过，但容易出问题。因为 Rust 对 `unsafe` 代码尝试创建空类型的实例没啥保护，一旦做了就是未定义行为。
        *   特别是把裸指针转成引用 `&Void` 更是未定义行为。
        *   用 `*const ()` (指向 ZST 的指针) 来模拟 `void*` 会好一些，至少把它转成引用 `&()` 是安全的，读写它也是空操作，而不是未定义行为。

4.  **外部类型 (Extern Types)** - 这是一个计划中的功能
    *   有个 RFC (Request for Comments，就是 Rust 的功能提案) 提议加入一种真正的“未知大小的类型”，叫做 `extern type`。
    *   这将能更准确地模拟像 C 语言的 `void*` 或者其他“只声明，未定义”的类型。
    *   但是，截至 Rust 2018，这个功能还在“卡壳”阶段，主要是在争论 `size_of_val::<MyExternType>()` （获取一个具体外部类型实例的大小）应该怎么表现。

**总结一下，这些“奇葩”类型：**

*   **DSTs (动态大小类型)**：编译时不知道多大，只能通过“胖指针”使用，指针里带着额外的大小信息。比如 `dyn Trait` 和 `[T]`。
*   **ZSTs (零大小类型)**：不占内存空间。在泛型编程里是优化利器，比如用 `()` 作为 `HashMap` 的值来实现高效的 `HashSet`。
*   **Empty Types (空类型)**：连实例都不能创建。用来在类型层面表示“不可能”，比如 `Result<T, Void>` 表示一个永不出错的操作。

这些特殊类型体现了 Rust 类型系统的强大和灵活性，但也给 `unsafe` 编程带来了一些需要特别注意的地方。