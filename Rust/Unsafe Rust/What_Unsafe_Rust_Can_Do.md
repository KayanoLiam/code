# What Unsafe Rust Can Do
我们来啃一下“Unsafe Rust 能做什么”这块硬骨头，用大白话把它说明白。

**核心思想：**

`unsafe` 代码块并不会让 Rust 变成一个完全不同的语言，它只是解锁了 **五种** 特别的、编译器无法保证安全的操作。这些操作之所以被“锁起来”，是因为一旦用错了，就会导致“未定义行为”（Undefined Behavior, UB），后果非常严重。

**`unsafe` 能干的五件事（只有这五件）：**

1.  **解引用裸指针 (Dereference raw pointers):**
    *   **大白话：** 直接操作内存地址。就像 C 语言里的 `*pointer` 操作。你可以读取或写入裸指针 (`*const T`, `*mut T`) 指向的内存。
    *   **危险点：** 如果指针是空的（null）、指向的内存已经被释放了（悬垂指针）、或者地址没对齐（比如一个 4 字节整数的地址不是 4 的倍数），直接访问就是 UB。

2.  **调用 `unsafe` 函数 (Call unsafe functions):**
    *   **大白话：** 调用那些被标记为 `unsafe fn` 的函数。
    *   **包括哪些？**
        *   C 语言函数 (FFI)。
        *   编译器内置的特殊函数 (intrinsics)。
        *   底层的内存分配函数 (raw allocator)。
        *   标准库或其他库里明确标为 `unsafe` 的函数（比如 `slice::get_unchecked`）。
    *   **危险点：** 这些函数通常有编译器无法检查的“前提条件”（契约）。比如 `get_unchecked` 要求索引必须在范围内。如果你没满足这些条件就调用，就是 UB。调用 C 函数时，如果参数类型、调用约定 (ABI) 搞错了，也是 UB。

3.  **实现 `unsafe` Trait (Implement unsafe traits):**
    *   **大白话：** 为你自己的类型实现那些被标记为 `unsafe trait` 的 Trait（比如 `Send`, `Sync`）。
    *   **危险点：** 实现 `unsafe trait` 等于你向编译器保证你的类型满足这个 Trait 的所有（通常是关于并发或内存安全的）契约。如果你撒谎了（类型实际上不满足契约），在某些情况下使用这个类型就可能导致 UB。

4.  **访问或修改可变的静态变量 (Access or modify mutable statics):**
    *   **大白话：** 读写全局变量 (`static mut`)。
    *   **危险点：** 全局可变状态是数据竞争（Data Race）的温床。多个线程同时读写同一个 `static mut` 变量而没有同步机制（比如锁）保护，就是 UB。所以访问它们必须在 `unsafe` 块里，并且由你来保证线程安全。

5.  **访问 `union` 的字段 (Access fields of unions):**
    *   **大白话：** 读取 `union` 结构里的数据。`union` 允许多个不同类型的字段共享同一块内存。
    *   **危险点：** 编译器不知道当前 `union` 里存的到底是哪个类型的有效数据。你必须自己保证你访问的那个字段正好是当前存储的那个类型。访问错误类型的字段是 UB。

**未定义行为 (Undefined Behavior, UB) 是啥？**

*   **最坏的情况！** UB 意味着你的程序行为变得完全不可预测。
*   编译器拿到有 UB 的代码，**可以做任何事情**：
    *   可能程序直接崩溃。
    *   可能悄无声息地产生错误结果。
    *   可能看起来正常运行，但只在特定情况或特定优化级别下才出问题。
    *   理论上，编译器甚至可以优化掉看似无关的代码，或者做出完全意想不到的行为。（虽然“格式化硬盘”是夸张说法，但强调的是其不可预测性和破坏性）。
*   **底线：绝对、绝对要避免 UB！**

**好消息：Rust 对 UB 的范围限制得比较严**

不像 C/C++ 那样 UB 遍地开花，Rust 核心语言层面，真正在乎并严格定义为 UB 的情况主要就下面这些：

1.  **指针问题：**
    *   解引用**悬垂指针**（指向已释放或无效内存的指针，包括 null）。
    *   解引用**未对齐指针**（指针地址不满足其指向类型的对齐要求）。
2.  **指针别名规则破坏：** （简单理解）同时存在不兼容的指针/引用指向同一数据，特别是存在可变引用 `&mut T` 时，不能有其他任何别名（`&T`, `*const T`, 另一个 `&mut T` 等）。
3.  **函数调用约定 (ABI) 错误：** 用错误的 ABI 调用函数，或者让 panic 跨越不同的 ABI 边界。
4.  **数据竞争 (Data Race)：** 多线程在没有同步的情况下同时访问（至少一个写）同一内存位置。
5.  **CPU 特性不匹配：** 在不支持某个 CPU 特性（如 AVX2 指令集）的机器上，运行了需要该特性才能正确执行的代码。
6.  **产生无效值 (Producing invalid values)：** 创建或传递了不符合其类型定义的数值。这是**一大类**，包括：
    *   `bool` 不是 `0` 或 `1`。
    *   `enum` 的值超出了其定义的判别式范围。
    *   函数指针 (`fn`) 是 `null`。
    *   `char` 的值不在合法的 Unicode 标量值范围内。
    *   `!`（Never 类型）竟然有了值（它定义为永不可能有值）。
    *   从**未初始化的内存**中读取整数、浮点数、裸指针，或者 `str` 包含未初始化的字节。（注意：读取未初始化内存是产生无效值的**方式**，根源是值无效）。
    *   **引用** (`&`, `&mut`) 或 `Box`：
        *   是悬垂的 (dangling)。
        *   是未对齐的 (unaligned)。
        *   指向了一个上面提到的无效值。
    *   **胖指针** (指向 slice 或 `dyn Trait` 的指针/引用) 的元数据无效：
        *   `dyn Trait` 的 vtable 指针不正确。
        *   `slice` 的长度值本身无效（比如来自未初始化内存）或者长度过大（超过 `isize::MAX`）。
    *   自定义无效值类型（如 `NonNull<T>`）的值是其定义中禁止的那个无效值（比如 `NonNull<T>` 里面存了 `null`）。

**什么是“悬垂 (dangling)”指针/引用？**

*   是 `null`。
*   或者它指向的内存范围内的所有字节，**并不都属于同一个已分配的内存块**。简单说，就是指向了无效或已释放的内存区域。
*   注意：对于 `slice` 和 `str`，它们的指针是指向整个数据范围的，所以它们的长度元数据**绝对不能**过大，否则也可能变成悬垂（指向了分配范围之外）。

**除了核心语言，UB 还可能来自：**

*   **`unsafe` 函数/Trait 的自定义规则：** 比如内存分配器规定，释放未分配的内存是 UB。
*   **编译器优化依赖的假设：** 比如 `Vec` 和 `Box` 内部依赖编译器优化，假设它们的指针永远不为 null。如果你通过 `unsafe` 手段让它们变成 null，可能就破坏了优化假设，导致 UB。

**Rust “安全”但不保证杜绝的事情（但通常也是 Bug）：**

Rust 的“安全”主要指的是**内存安全**和**类型安全**，防止 UB。但以下这些问题，Rust **不**（或者说很难在编译期完全）阻止，它们不属于 UB，但你的程序可能还是错的：

*   **死锁 (Deadlock):** 两个或多个线程互相等待对方释放资源。
*   **逻辑上的数据竞争 (Race condition):** 不是内存层面的 UB，而是程序逻辑错误导致的结果依赖于线程执行顺序。
*   **内存泄漏 (Leak memory):** 分配的内存不再被使用，但也没有被释放。（Rust 通过所有权系统大大减少了泄漏，但比如循环引用 `Rc<RefCell<...>>` 还是可能泄漏）。
*   **整数溢出 (Integer overflow):** 标准的 `+`, `-`, `*` 等操作，在 release 模式下溢出会进行环绕（比如 `u8` 的 `255 + 1` 变成 `0`），这是**确定行为**，不是 UB。（Debug 模式下默认会 panic）。
*   **程序中止 (Abort the program):** 比如显式调用 `panic!` 或遇到无法恢复的错误。
*   **逻辑错误导致搞破坏 (Delete the production database):** 你的代码逻辑错了，干了不该干的事。

**总结：**

`unsafe` 给了你五种强大的、能直接操作底层或绕过编译器检查的能力。用好它们能实现 Safe Rust 做不到的事情（性能优化、FFI 等），但用错了就会导致 UB，让程序彻底玩完。Rust 对 UB 有明确的（虽然复杂的）定义，核心是防止内存错误、类型混淆和并发问题。而像死锁、内存泄漏、逻辑错误这些虽然也是问题，但不属于 Rust 安全性保证的核心范畴（即不保证 100% 杜绝，但提供了工具帮助避免）。理解 UB 的边界是写好 `unsafe` 代码的关键。