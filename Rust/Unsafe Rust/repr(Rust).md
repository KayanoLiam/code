# repr(Rust)

Rust 里面数据是怎么在内存里排队的，特别是默认情况下（也就是 `repr(Rust)`，这是 Rust 默认的安排方式）。咱们一点点拆开看：

1.  **对齐（Alignment）是基本要求**
    *   想象一下，你有一堆不同大小的积木（数据类型），要把它们放到一排格子里（内存地址）。
    *   **对齐 (Alignment)**：就像规定了某些积木只能放在特定的格子里。比如，一个对齐是 4 字节的积木，它只能放在地址是 4 的倍数（0, 4, 8, 12...）的格子里。对齐是 2 字节，就只能放偶数地址。对齐是 1 字节，就随便放哪个格子都行。
    *   对齐最少是 1，而且总是 2 的多少次方（比如 1, 2, 4, 8, 16...）。
    *   **为啥要对齐？** 简单说，电脑处理器（CPU）读取对齐的数据会更快。如果不对齐，CPU 可能要读两次内存才能拿到完整数据，效率就低了。

2.  **基本类型怎么对齐？**
    *   像 `u8` (1字节整数), `u32` (4字节整数), `f64` (8字节浮点数) 这些基本类型，通常情况下，它们的对齐值和它们本身的大小是一样的。比如 `u32` 大小是 4 字节，对齐也是 4 字节。
    *   但！这玩意儿**不是绝对的，跟你的电脑（平台）有关**。比如在某些 x86 架构的电脑上，`u64`（8字节）和 `f64`（8字节）可能只要求对齐到 4 字节。

3.  **类型大小和对齐的关系**
    *   一个类型的**总大小**，必须是它**对齐值的倍数**。
    *   比如一个东西对齐是 4 字节，那它的大小可以是 4 字节、8 字节、12 字节等等，但不能是 5 字节或 7 字节。
    *   **为啥要这样？** 这样能保证，如果你有一堆同样的东西排成一排（比如数组），你每次跳过“一个东西的大小”就能准确找到下一个东西的开头，并且这个开头也一定是符合对齐要求的。

4.  **Rust 里组合数据的几种方式**
    *   `structs` (结构体)：给一堆不同类型的数据起了个名字，打包在一起。
    *   `tuples` (元组)：匿名的结构体，也是把一堆数据打包。
    *   `arrays` (数组)：一堆相同类型的数据排排坐。
    *   `enums` (枚举)：表示“是这个，或者是那个，或者是另外一个”的情况。比如 `Option<T>` 要么是 `Some(T)` 要么是 `None`。
    *   `unions` (联合体)：比较少见，允许多个字段共享同一块内存，但一次只有一个字段是有效的（这个 Rust 默认不怎么管，用起来要特别小心）。

5.  **组合数据默认怎么布局 (`repr(Rust)`)**
    *   **对齐**：一个组合结构（比如 `struct`）的对齐值，等于它里面所有字段（成员变量）中**最大的那个对齐值**。
    *   **填充 (Padding)**：为了保证每个字段都能放在自己要求的对齐地址上，并且整个结构体的大小也是它自身对齐值的倍数，Rust 会在字段之间或者结构体的末尾**自动塞一些“填充字节”**（空白）。这些填充字节啥也不干，就是占个位置。

    举个例子：
    ```rust
    struct A {
        a: u8,  // 1 字节, 假设对齐 1
        b: u32, // 4 字节, 假设对齐 4
        c: u16, // 2 字节, 假设对齐 2
    }
    ```
    *   最大对齐是 `b` 的 4 字节，所以整个 `struct A` 对齐是 4 字节。
    *   可能的布局：
        ```
        a: u8 (1 byte)
        _pad1: [u8; 3] (3 bytes padding)  // 为了让 b 能从 4 的倍数地址开始
        b: u32 (4 bytes)
        c: u16 (2 bytes)
        _pad2: [u8; 2] (2 bytes padding)  // 为了让整个结构体大小是 4 的倍数 (1+3+4+2+2 = 12, 12是4的倍数)
        ```
        总大小 12 字节。

    *   **字段顺序不保证！** Rust 编译器为了优化，可能会**重新排列字段的顺序**。比如上面的 `struct A`，编译器也可能把它排成：
        ```
        b: u32 (4 bytes)
        c: u16 (2 bytes)
        a: u8  (1 byte)
        _pad: u8 (1 byte padding) // 4+2+1+1 = 8, 8是4的倍数
        ```
        总大小 8 字节，更省空间！

    *   **除了数组**（数组里的元素是紧挨着按顺序放的），其他组合类型（`struct`, `tuple`, `enum`）的字段在内存中的具体顺序，**Rust 默认是不给你保证的**。
    *   也就是说，即使两个 `struct` 定义看起来一模一样（字段名和类型都一样），Rust 也不保证它们的内存布局（字段顺序、填充）会完全一样。
        ```rust
        struct A { a: i32, b: u64 }
        struct B { a: i32, b: u64 }
        ```
        两个 `A` 类型的实例，内部布局肯定一样。但一个 `A` 和一个 `B`，Rust 不保证它们布局一样（虽然在这个简单例子里很可能一样，但理论上可以不一样）。

6.  **为啥 Rust 要这么“任性”地调整布局？**
    *   **省空间！**
    *   考虑泛型结构体：
        ```rust
        struct Foo<T, U> {
            count: u16, // 2字节
            data1: T,
            data2: U,
        }
        ```
        如果 `T` 是 `u16` (2字节)，`U` 是 `u32` (4字节)：
        `Foo<u16, u32>` -> `count(u16), data1(u16), data2(u32)`
        这样排列可能很紧凑。

        如果 `T` 是 `u32` (4字节)，`U` 是 `u16` (2字节)：
        `Foo<u32, u16>` -> `count(u16), data1(u32), data2(u16)`
        如果按这个顺序，`count` 后面可能要加 2 字节的填充，才能让 `data1(u32)` 对齐到 4 字节。`data2(u16)` 后面可能也要加填充让整个结构体大小是对齐值的倍数。
        但如果 Rust 把字段重排成 `data1(u32), count(u16), data2(u16)`，就可能更省空间。

7.  **枚举（Enum）的布局更复杂**
    *   一个朴素的想法是，枚举像这样存：
        ```rust
        enum Foo {
            A(u32),
            B(u64),
            C(u8),
        }
        // 可能像这样：
        struct FooRepr {
            data: u64, // 用最大的成员的大小来存数据
            tag: u8,   // 一个标记，说明当前是 A, B, 还是 C
        }
        ```
        确实，Rust 大概是这么做的。

    *   **但是！Rust 有优化！** 最经典的叫“空指针优化”（null pointer optimization）。
        比如 `Option<&T>` (一个可选的引用，要么是 `Some(&T)` 指向某个东西，要么是 `None` 表示没有)。
        我们知道，有效的引用地址不可能是 0（null）。Rust 就利用这一点：
        *   如果指针是 `null` (0)，就表示它是 `None`。
        *   如果指针不是 `null`，就表示它是 `Some(&T)`，指针的值就是 `&T` 的地址。
        这样，根本不需要额外的 `tag` 来区分 `Some` 和 `None` 了！
        结果就是 `Option<&T>` 的大小和 `&T` 本身的大小一样！非常省空间。
        很多类型比如 `Box<T>`, `Vec<T>`, `String`, `&T`, `&mut T` 都是“非空指针”，所以 `Option` 包裹它们的时候都能享受这个优化。

    *   更进一步，如果枚举里有嵌套枚举，或者某些字段的值域是有限的，Rust 理论上可以用更复杂的算法来“压缩”标记位，把标记信息塞到数据的“空隙”里。
    *   因为有这么多优化的可能性，所以 Rust **目前特意不明确规定枚举的内存布局**，给自己留足了优化的空间。

**核心思想：**

*   **对齐**是为了性能。
*   Rust 默认的 `repr(Rust)` 布局策略会**自动加填充**来满足对齐，并且为了**省空间**，它可能会**重新排列字段的顺序**，甚至对枚举进行各种**高级优化**。
*   因为这些优化，Rust **不保证不同类型之间（即使定义相似）或同一泛型类型的不同实例化之间的内存布局是一致的（除了数组和相同具体类型）。**
*   如果你需要精确控制内存布局（比如要和 C 语言交互），那就不能用默认的 `repr(Rust)`，需要用其他的 `repr` 选项，比如 `repr(C)`。

简单说，默认情况下，Rust 会在保证正确的前提下，尽可能聪明地安排数据怎么放，目标是又快又省。但这也意味着你不能想当然地认为字段会按照你写的顺序排列。