# Meet Safe and Unsafe
咱们接着用大白话聊聊这部分：“遇见安全与不安全”。

**核心思想：**

这节主要讲的是，为啥 Rust 这个以“安全”著称的语言，里面还藏着个“不安全”的部分 (`unsafe`)？它解释了这两部分是啥，以及为啥要有这种设计。

**为啥要关心“底层细节”？**

*   平时写代码，咱们可能不太关心一个空元组 `()` 占多少内存这种小事。
*   但有时候，这些**底层实现的细节就变得很重要**了：
    *   **性能：** 为了让程序跑得更快，可能需要精确控制内存布局或操作。
    *   **正确性（特殊场景）：** 当你直接跟**硬件**、**操作系统**或者**其他语言（比如 C 语言写的库）** 打交道时，必须得懂底层是怎么回事，否则程序可能就错了。

**其他“安全”语言遇到这问题咋办？**

当一个标榜“安全”的语言（比如 Java、Python 等，这里主要是对比思路）的程序员需要控制底层时，通常有几种不太理想的选择：

1.  **“哄”编译器：** 写一些奇奇怪怪的代码，希望编译器“聪明地”理解你的意图，帮你优化成想要的样子。（通常不靠谱，而且可能下次编译就不灵了）
2.  **“扭曲”设计：** 为了达到底层的效果，把代码写得不符合语言的习惯，或者搞得很复杂、很难看懂。（代码质量下降）
3.  **求助“外援”（比如 C 语言）：** 把需要控制底层的那部分用 C 语言来写。这是最常见的，尤其是当你要调用的系统接口只有 C 语言版本时。

**用 C 语言当“外援”的问题：**

*   **C 语言本身不安全：** C 语言很容易写出内存错误（比如访问野指针、缓冲区溢出），导致程序崩溃或安全漏洞。
*   **“跨语言”交流困难：** 让两种不同的语言（比如一个安全的语言和不安全的 C）协同工作很麻烦。得确保它们对数据的理解一致，不会互相干扰（比如内存管理方式不同，可能导致问题）。

**Rust 的解决方案：既安全，又不安全**

*   和 C 不一样，Rust 首先是一个**安全的**编程语言。
*   但同时，Rust 也**像 C 一样**，是一个**不安全的**编程语言。
*   更准确地说：**Rust 语言内部包含了两个“子语言”：安全的 Rust (Safe Rust) 和 不安全的 Rust (Unsafe Rust)。**

**安全的 Rust (Safe Rust):**

*   这就是我们平时打交道的、**真正的 Rust**。
*   如果你只写 Safe Rust，**永远不用担心**类型安全和内存安全问题。
*   编译器会帮你检查，杜绝悬垂指针、使用已释放内存、数据竞争等 C/C++ 里常见的“未定义行为”（Undefined Behavior, UB）。这些 UB 是程序崩溃和安全漏洞的主要来源。
*   Rust 的标准库提供了很多好用的工具，让你只用 Safe Rust 就能写出高性能、符合 Rust 风格的程序。

**不安全的 Rust (Unsafe Rust):**

*   它**不是**一个完全不同的语言。语法、规则什么的**跟 Safe Rust 一模一样**。
*   它只是给你**解锁了一些额外的、明确（Definitely）不安全的操作权限**。这些操作是 Rust 编译器无法保证其安全性的。
*   **什么时候需要它？**
    *   跟其他语言（主要是 C）交互 (FFI)。
    *   写一些标准库没提供的非常底层的抽象（比如自己实现一个数据结构，需要手动管理内存）。
    *   写 Rust 标准库本身（标准库内部实现了很多 `unsafe` 代码，来提供安全的接口）。
    *   当你需要做一些类型系统无法理解的操作，比如直接捣鼓内存里的二进制位（"frob some dang bits" 是句俚语，就是瞎搞比特位的意思）。

**这种“内外有别”的设计有啥好处？**

*   我们既能获得像 C 语言那样的**对底层实现的精细控制能力**。
*   又**避免了**把一个完全安全的语言和一个完全不安全的语言（比如 Java + C）硬凑在一起的大部分麻烦。因为 Safe Rust 和 Unsafe Rust 本质上还是同一种语言，它们的交互更“自然”。

**但是，也有代价（这就是这本书要讲的）：**

*   虽然集成得更好，但问题依然存在。最主要的是：当你开始写 `unsafe` 代码时，你就**必须非常清楚 Safe Rust 默认遵守的那些规则和假设**（比如关于内存、指针、所有权等的底层规则）。
*   你写的 `unsafe` 代码，或者与 `unsafe` 代码交互的部分，**必须由你（程序员）来手动保证**这些规则没有被破坏。编译器不再为你负责这部分安全检查了。
*   **这本书（Rustonomicon）的目的**，就是教你 Safe Rust 到底依赖哪些底层假设，以及如何在写 `unsafe` 代码时维护好这些假设，别把事情搞砸。

**总结一下大白话：**

Rust 就像一个工具箱。大部分时候，你用的是箱子里那些设计精良、保证你不会伤到自己的“安全工具”（Safe Rust）。但有时候，你需要干一些特别精细或者特别“危险”的活儿（比如跟旧设备打交道、或者追求极致性能），这时候 Rust 提供了一套“专业级但危险的工具”（Unsafe Rust），它放在一个标着“危险！后果自负！”的 `unsafe` 盒子里。用这些工具能干安全工具干不了的活，但你必须自己承担所有风险，确保自己知道自己在干嘛，不会把自己弄伤（不会写出内存错误）。《Rustonomicon》就是这套危险工具的使用说明和安全操作手册。