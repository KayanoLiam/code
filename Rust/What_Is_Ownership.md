# 什么是所有权 (What Is Ownership)
**所有权 (Ownership)** 这个 Rust 的核心概念。

**为啥要有“所有权”这玩意儿？**

咱们先想想其他编程语言怎么管理内存（就是程序运行时存放数据的地方）。

1.  **垃圾回收 (Garbage Collection - GC)，像 Java, Python, Go：** 有个“垃圾佬”在后台跑，时不时检查哪些内存数据没人在用了，然后就自动回收掉。优点是程序员省心，不容易出内存错误。缺点是“垃圾佬”工作时可能会暂停你的程序（影响性能），而且你没法精确控制内存啥时候被回收。
2.  **手动管理，像 C, C++：** 程序员自己是“内存管理员”，需要明确地告诉程序什么时候申请内存 (`malloc`)，什么时候释放内存 (`free`)。优点是控制力强，性能可能很高。缺点是太容易出错了！比如：
    *   忘记释放（**内存泄漏**）：内存越用越少。
    *   释放之后还用（**悬垂指针**）：程序访问了无效内存，可能崩溃或出诡异问题。
    *   释放两次（**二次释放**）：也是严重的错误。
    这些内存安全问题是 C/C++ 程序 Bug 的主要来源之一。

**Rust 的选择：所有权系统 - 编译时就搞定！**

Rust 想了一个绝妙的办法：它既不要垃圾回收器（避免性能损耗和暂停），也不让程序员手动管理那么容易出错。它引入了**所有权系统**，这是一套**规则**，让**编译器**在**编译代码的时候**就能分析清楚每块内存应该由谁负责、什么时候不再需要、什么时候应该释放。如果你的代码违反了这些规则，**编译就不会通过**！

这意味着很多潜在的内存错误在程序运行之前就被编译器消除了，既安全又高效！

**所有权的核心规则 (就三条！)**

记住这三条规则，你就抓住了所有权的精髓：

1.  **每个值都有一个对应的“所有者”(Owner)。** （这个值被绑定到一个变量上，这个变量就是所有者）。
2.  **在任何时刻，一个值只能有一个所有者。** （不能多人同时“拥有”同一个东西）。
3.  **当所有者离开作用域 (Scope) 时，它所拥有的值会被自动“丢弃”(Dropped)。** （人走茶凉，变量没了，它拥有的内存也就被释放了）。

咱们来详细看看这些规则意味着什么。

**1. 变量作用域 (Scope)**

作用域就是变量在程序里有效的范围。很简单，通常就是一对大括号 `{}` 里的范围。

```rust
fn main() {
    // s 在这里还不能用，因为它还没被声明
    {                      // s 的作用域开始
        let s = "hello";   // s 从这里开始有效
        // 在这里可以用 s
        println!("s is: {}", s);
    }                      // s 的作用域到此结束，s 不再有效
    // 在这里再用 s 就会报错了！
}
```

**2. `String` 类型：一个需要所有权的典型例子**

为了更好地理解所有权，我们经常用 `String` 类型来举例。`String` 和我们之前用的字符串字面量 (`let s = "hello";` 里的 `"hello"`) 不太一样：

*   **字符串字面量 (`&str`)**: 它的内容是硬编码在程序里的，大小固定，通常存储在程序的只读内存段，速度快，天生就是不可变的。它不需要复杂的所有权管理。
*   **`String` 类型**: 它是**可变**的，可以在运行时增长或缩短。为了支持这种灵活性，它的内容存储在**堆 (Heap)** 上。堆是一块在程序运行时可以动态申请和释放的内存区域。管理堆内存比管理栈内存要复杂，这就是所有权大显身手的地方。

    ```rust
    let mut s = String::from("hello"); // 从字符串字面量创建 String，内容在堆上
    s.push_str(", world!"); // String 可以修改
    println!("{}", s); // 输出 "hello, world!"
    ```

**内存与分配：栈 (Stack) vs. 堆 (Heap)**

简单理解：

*   **栈 (Stack):** 像一叠盘子，放东西（分配内存）和取东西（释放内存）都只能在最顶上操作，非常快，后进先出 (LIFO)。函数调用、局部变量（如果大小在编译时已知，比如整数、布尔值、固定大小的数组、元组等）通常放在栈上。
*   **堆 (Heap):** 像一个大仓库，你要存东西时，得找操作系统这个“仓库管理员”（内存分配器）给你找一块空地（可能不连续），它会返回地址给你。存取速度比栈慢，但可以存放大小在运行时才能确定或者可能变化的数据（比如 `String`）。用完后需要告诉“管理员”把这块地还回去（释放内存）。

`String` 类型需要在堆上分配内存来存储它的文本内容，因为它的大小可能变化。

**所有权如何管理 `String` 的堆内存？**

1.  **申请内存:** 当你调用 `String::from("hello")` 时，它会向操作系统请求一块堆内存来存放 "hello" 这几个字符。
2.  **使用内存:** 变量 `s` 现在“拥有”了这块堆内存（以及一些记录长度、容量的元数据存在栈上）。你可以使用 `s` 来访问和修改堆上的数据。
3.  **自动释放内存:** 当变量 `s` 离开它的作用域时（比如函数结束），Rust 会自动调用一个特殊的函数 `drop`。`String` 类型的 `drop` 函数的实现会负责把 `s` 拥有的那块**堆内存**还给操作系统。这个过程是**自动**的，你不需要手动写释放代码！这就是规则 3 的体现。

**所有权转移 (Move)：当你把“玩具”送人**

现在来看规则 2：“一个值只能有一个所有者”。这在处理像 `String` 这样拥有堆内存的数据时特别重要。看这个例子：

```rust
let s1 = String::from("hello");
let s2 = s1; // 这里发生了什么？

// println!("s1 is: {}", s1); // <-- 如果取消这行注释，编译会报错！
println!("s2 is: {}", s2);
```

你可能会以为 `s2 = s1` 是把 `s1` 的内容复制了一份给 `s2`。但对于像 `String` 这样包含堆指针的数据，Rust **默认不进行“深拷贝”**（即复制堆上的数据），因为复制堆数据可能很耗时。

实际上发生的是**所有权转移 (Move)**：

1.  `s1` 原本拥有栈上的指针、长度、容量信息，以及堆上的 "hello" 数据。
2.  `let s2 = s1;` 这行代码做了“浅拷贝”：把 `s1` 栈上的指针、长度、容量**复制**给了 `s2`。现在 `s1` 和 `s2` 都指向**同一块**堆内存！
3.  但是，为了保证**只有一个所有者**（规则 2），并且为了防止当 `s1` 和 `s2` 都离开作用域时，程序尝试**释放同一块堆内存两次**（这会导致二次释放错误！），Rust 做了一个决定：**一旦 `s1` 的所有权转移给了 `s2`，`s1` 就变成无效的了！**

这就是为什么上面代码里如果尝试使用 `s1`，编译器会报错，告诉你 `s1` 的值已经被 "moved"（移动）了。

这种行为叫做 **Move**。对于管理堆内存的类型（如 `String`, `Vec<T>`, `Box<T>` 等），赋值操作默认是 Move。

**显式复制 (Clone)：我想要一份副本**

如果你确实想要复制堆上的数据，创建一个完全独立的 `String` 副本，你需要显式地调用 `clone()` 方法：

```rust
let s1 = String::from("hello");
let s2 = s1.clone(); // 显式调用 clone() 进行深拷贝

println!("s1 = {}, s2 = {}", s1, s2); // s1 和 s2 都有效，指向不同的堆内存
```
`clone()` 会复制堆上的数据，所以 `s1` 和 `s2` 现在各自拥有独立的 "hello" 数据副本。但请注意，`clone()` 可能是一个耗时的操作。

**只在栈上的数据：拷贝 (Copy)**

那么，像整数这种简单的类型呢？

```rust
let x = 5; // x 是 i32，存在栈上
let y = x; // 这里发生了什么？

println!("x = {}, y = {}", x, y); // x 和 y 都有效！
```

这段代码可以正常编译和运行！为什么 `x` 在赋值给 `y` 之后仍然有效？

因为像 `i32` 这样的整数类型，它们的值完全存储在**栈**上，没有指向堆的指针。复制一个 `i32` 的成本非常低（就是复制几个字节）。对于这种类型，Rust 认为进行“深拷贝”（也就是直接复制栈上的值）完全没问题，而且没必要让旧的变量失效。

这种行为叫做 **Copy**。如果一个类型实现了 `Copy` 这个特殊的**标记特性 (marker trait)**，那么它在赋值时会执行 Copy 而不是 Move。

哪些类型实现了 `Copy`？
*   所有整数类型 (`u8`, `i32` 等)
*   布尔类型 (`bool`)
*   所有浮点数类型 (`f32`, `f64`)
*   字符类型 (`char`)
*   **只包含**以上这些 `Copy` 类型的**元组 (tuple)**。比如 `(i32, bool)` 是 `Copy` 的，但 `(i32, String)` 就不是。

**注意：** 如果一个类型需要自己管理资源（比如像 `String` 那样需要在 `drop` 时释放堆内存），它就不能实现 `Copy`。`Copy` 和 `Drop` 特性是互斥的。

**所有权与函数**

把值传递给函数，或者从函数返回值，也遵循同样的所有权规则（Move 或 Copy）：

*   **传递所有权 (Move):** 把一个拥有堆数据的类型（如 `String`）传给函数，所有权会**转移**给函数的参数。原来的变量在函数调用后就失效了。

    ```rust
    fn main() {
        let s = String::from("hello");
        takes_ownership(s); // s 的所有权转移给了 takes_ownership 函数的 some_string 参数
        // println!("{}", s); // 错误！s 在这里已经无效了
    }
    fn takes_ownership(some_string: String) { // some_string 获得了所有权
        println!("{}", some_string);
    } // some_string 离开作用域，调用 drop 释放内存
    ```

*   **传递副本 (Copy):** 把一个实现了 `Copy` 的类型（如 `i32`）传给函数，实际上传递的是值的**副本**。原来的变量仍然有效。

    ```rust
    fn main() {
        let x = 5;
        makes_copy(x); // x 的值被复制给了 makes_copy 函数的 some_integer 参数
        println!("{}", x); // x 在这里仍然有效！可以继续使用
    }
    fn makes_copy(some_integer: i32) { // some_integer 是 x 的副本
        println!("{}", some_integer);
    } // some_integer 离开作用域，因为是栈上数据，没啥特别需要做的
    ```

*   **函数返回值与所有权：** 函数也可以返回值，这个过程同样会**转移所有权**。

    ```rust
    fn main() {
        let s1 = gives_ownership(); // s1 获得了函数返回的 String 的所有权
        let s2 = String::from("hello");
        let s3 = takes_and_gives_back(s2); // s2 的所有权转移给函数，函数又返回了一个 String，所有权转移给 s3
        println!("s1: {}, s3: {}", s1, s3);
        // println!("{}", s2); // 错误！s2 已失效
    }
    fn gives_ownership() -> String { // 返回一个 String
        let some_string = String::from("yours");
        some_string // 返回 String，所有权向外转移
    }
    fn takes_and_gives_back(a_string: String) -> String { // 接收 String，返回 String
        a_string // 返回 String，所有权向外转移
    }
    ```

**小结与展望**

所有权系统通过这三条简单的规则，在编译时就保证了内存安全，避免了 GC 的开销。

*   赋值操作对于堆数据类型（如 `String`）是 **Move**，旧变量失效。
*   赋值操作对于栈数据类型（如 `i32`，实现了 `Copy` trait）是 **Copy**，旧变量仍有效。
*   可以使用 `.clone()` 对堆数据进行显式**深拷贝**。
*   函数传参和返回值也遵循 Move/Copy 规则。

虽然所有权保证了安全，但每次都转移所有权有时候会显得有点麻烦（比如函数用完数据后还得把所有权还回来）。为了解决这个问题，Rust 引入了**借用 (Borrowing)** 和**引用 (References)** 的概念，允许我们在不转移所有权的情况下安全地使用数据。这就是下一节要讲的内容了！