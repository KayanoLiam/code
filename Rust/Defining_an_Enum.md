# 枚举 (Enums)

你想啊，之前咱们聊过**结构体 (structs)**，它就像一个打包盒，把相关的几个数据（比如一个“长方形”的“宽度”和“高度”）打包在一起。

那**枚举 (enums)** 呢？它不一样，它是告诉你“一个东西只能是这几种可能性中的一种”。
打个比方，我们说“形状”，它可能是“长方形”，也可能是“圆形”，还可能是“三角形”。这种“是A，或者是B，或者是C”的情况，用枚举来表示就最合适了。Rust 允许我们把这些可能性“枚举”出来，变成一种类型。

**为啥要用枚举呢？举个例子：IP 地址**

*   现在主流的 IP 地址有两种标准：版本四 (IPv4) 和版本六 (IPv6)。
*   一个 IP 地址，它**要么是 IPv4，要么是 IPv6**，不可能同时是两种。
*   这种“非此即彼”的特性，就特别适合用枚举来表示。因为枚举的一个值，也只能是它定义的那些“变体”（variants）中的一个。
*   但不管是 IPv4 还是 IPv6，它们本质上都是 IP 地址，所以在处理通用的 IP 地址逻辑时，我们希望把它们看作是同一种类型。

**用代码怎么写呢？**

我们可以定义一个叫 `IpAddrKind` （IP 地址种类）的枚举，列出可能的种类：

```rust
enum IpAddrKind {
    V4, // 这是变体一：版本四
    V6, // 这是变体二：版本六
}
```

现在，`IpAddrKind` 就是我们自定义的一个数据类型了，可以在代码里用了。

**创建枚举的实例 (Enum Values)**

怎么用这个 `IpAddrKind` 呢？可以这样创建它的具体实例：

```rust
let four = IpAddrKind::V4; // four 是一个 IpAddrKind 类型的值，具体是 V4
let six = IpAddrKind::V6;  // six 也是一个 IpAddrKind 类型的值，具体是 V6
```

注意：
*   枚举的变体（`V4`, `V6`）是“属于”枚举名（`IpAddrKind`）的，用两个冒号 `::` 来连接。
*   这样做的好处是，`IpAddrKind::V4` 和 `IpAddrKind::V6` 它俩都是 `IpAddrKind` 这个类型。
*   所以，你可以定义一个函数，它的参数是 `IpAddrKind` 类型的，然后你传 `IpAddrKind::V4` 或者 `IpAddrKind::V6` 进去都没问题：

```rust
fn route(ip_kind: IpAddrKind) { /* ... */ }

route(IpAddrKind::V4);
route(IpAddrKind::V6);
```

**枚举还能做得更多：带上数据！**

刚才那个 `IpAddrKind` 只告诉了我们 IP 地址的“种类”，但没存真正的 IP 地址数据（比如 "127.0.0.1"）。

你可能会想，既然学了结构体，可以这么干：

```rust
enum IpAddrKind { // 先定义种类
    V4,
    V6,
}

struct IpAddr { // 再定义一个结构体来存具体信息
    kind: IpAddrKind,    // 种类
    address: String,     // 地址字符串
}

let home = IpAddr {
    kind: IpAddrKind::V4,
    address: String::from("127.0.0.1"),
};

let loopback = IpAddr {
    kind: IpAddrKind::V6,
    address: String::from("::1"),
};
```

这种方法，我们用了一个结构体 `IpAddr`，它有两个字段：`kind`（类型是 `IpAddrKind` 枚举）和 `address`（类型是 `String`）。这样就把种类和地址数据捆绑起来了。

**但是，用枚举可以更简洁！可以直接把数据放到枚举的变体里！**

我们可以这样重新定义 `IpAddr` 枚举，让 `V4` 和 `V6` 变体自己就带着一个 `String` 值：

```rust
enum IpAddr {
    V4(String),       // V4 变体，它关联一个 String 类型的数据
    V6(String),       // V6 变体，它也关联一个 String 类型的数据
}

let home = IpAddr::V4(String::from("127.0.0.1")); // 创建 V4 类型的 IP 地址，并传入数据
let loopback = IpAddr::V6(String::from("::1"));   // 创建 V6 类型的 IP 地址，并传入数据
```

看，这样就不用额外定义一个结构体了，直接把数据“附加”到枚举的每个变体上。
而且，这里有个小细节：当你定义枚举变体时，比如 `IpAddr::V4(String)`，那么 `IpAddr::V4` 就好像变成了一个“函数”，你调用它（比如 `IpAddr::V4(...)`），传入一个 `String` 参数，它就会返回一个 `IpAddr` 类型的实例。这是 Rust 自动帮你做好的。

**枚举的另一个巨大优势：每个变体可以有不同类型和数量的数据！**

*   IPv4 地址通常是四个 0 到 255 之间的数字（比如 `127.0.0.1`）。
*   如果我们想把 IPv4 地址存成四个 `u8`（无符号8位整数）类型的值，但 IPv6 地址仍然存成一个 `String`，用上面那种“结构体里套枚举”或者“枚举变体都带同一种数据”的方式就不行了。
*   但枚举可以轻松搞定：

```rust
enum IpAddr {
    V4(u8, u8, u8, u8), // V4 变体，关联四个 u8 类型的数据
    V6(String),           // V6 变体，关联一个 String 类型的数据
}

let home = IpAddr::V4(127, 0, 0, 1); // V4 数据是四个数字
let loopback = IpAddr::V6(String::from("::1")); // V6 数据是一个字符串
```

这就很灵活了！

**标准库里的 `IpAddr`**

其实啊，IP 地址这种东西太常用了，Rust 的标准库里已经帮我们定义好了一个 `IpAddr` 枚举。它跟我们上面想的差不多，也是 `V4` 和 `V6` 两个变体，但它把具体的地址数据分别用两个不同的结构体（`Ipv4Addr` 和 `Ipv6Addr`）包装起来，再放到枚举的变体里：

```rust
// 标准库里大概是这样定义的 (简化版)
struct Ipv4Addr { /* ...一些字段... */ }
struct Ipv6Addr { /* ...一些字段... */ }

enum IpAddr { // 这是标准库的 IpAddr
    V4(Ipv4Addr), // V4 变体，关联一个 Ipv4Addr 结构体
    V6(Ipv6Addr), // V6 变体，关联一个 Ipv6Addr 结构体
}
```

这说明，枚举的变体里面啥都能放：字符串、数字、结构体，甚至你还可以放另一个枚举！而且，标准库里的东西，很多时候跟你自己能想出来的也差不太多。
（顺便一提，即使标准库里有 `IpAddr`，我们自己也可以定义一个同名的 `IpAddr`，只要不把标准库的那个导入到我们当前的作用域就没冲突。）

**再看一个花样更多的枚举例子：`Message`**

这个 `Message` 枚举，它的每个变体带的数据类型和数量都不一样：

```rust
enum Message {
    Quit,                          // Quit 变体：啥数据也不带
    Move { x: i32, y: i32 },       // Move 变体：带有命名的字段 x 和 y，像个小结构体
    Write(String),                 // Write 变体：带一个 String
    ChangeColor(i32, i32, i32),   // ChangeColor 变体：带三个 i32 整数
}
```

*   `Quit`：光杆司令，不带任何数据。
*   `Move`：像个结构体一样，有 `x` 和 `y` 两个命名字段。
*   `Write`：包含一个 `String`。
*   `ChangeColor`：包含三个 `i32`。

定义这样的枚举，跟你定义好几种不同的结构体有点像（比如定义 `QuitMessage` 结构体、`MoveMessage` 结构体等等）。但用枚举的好处是，它们都被归到 `Message` 这一个统一的类型下面。如果你想写一个函数，能接收 *任何一种* 这类消息，用 `Message` 这个单一类型就比用一堆不同类型的结构体方便多了。

**枚举也能有方法 (methods)**

就像我们可以给结构体定义方法一样（用 `impl` 关键字），我们也可以给枚举定义方法。比如给上面的 `Message` 枚举定义一个叫 `call` 的方法：

```rust
impl Message {
    fn call(&self) {
        // 方法体，在这里根据 self 是哪个 Message 变体来做不同的事
        // self 指向调用这个方法的 Message 实例
    }
}

let m = Message::Write(String::from("hello")); // 创建一个 Message 实例
m.call(); // 调用它的 call 方法
```
当 `m.call()` 执行时，`call` 方法体里的 `self` 就代表 `m` 这个 `Message::Write(String::from("hello"))` 的值。

**接下来要讲的：`Option` 枚举（非常重要！）**

标准库里还有一个非常常用、非常有用的枚举，叫 `Option`。

`Option` 枚举专门用来处理一种非常普遍的情况：**一个值，它要么是“某个东西”，要么是“啥也没有”**。

*   比如，你去一个列表里取第一个元素。如果列表不是空的，你就得到一个值。如果列表是空的，你就啥也得不到。
*   用类型系统来表达这个概念，意味着编译器可以帮你检查，你是不是把所有该处理的情况（“有东西”和“啥也没有”）都处理了。这能防止很多在其他语言里常见的 bug。

**编程语言的设计，不光看它加了啥功能，也看它 *没加* 啥功能。**
*   Rust 就**没有**很多其他语言都有的 `null`（空值）这个特性。`null` 的意思就是“这里没有值”。在有 `null` 的语言里，变量通常有两种状态：“是 null” 或者 “不是 null”。
*   `null` 的发明者 Tony Hoare 自己都说，这是他“价值十亿美元的错误”。因为如果你试图把一个 `null` 值当成一个非 `null` 值来用，程序就会出错（比如崩溃）。这种错误太容易犯了。

**Rust 的解决方案：`Option<T>` 枚举**

*   `null` 想要表达的“当前值无效或缺失”这个概念本身是有用的，只是 `null` 的实现方式有问题。
*   所以，Rust 没有 `null`，但它有一个枚举可以表示“值存在或缺失”的概念。这个枚举就是 `Option<T>`，标准库是这么定义的：

```rust
enum Option<T> {
    None,     // 表示“啥也没有”
    Some(T),  // 表示“有东西”，T 代表那个东西的类型
}
```

*   `Option<T>` 太有用了，所以它和它的变体 `Some`、`None` 都被包含在“预导入”（prelude）里了，你不需要手动 `use Option::*` 就能直接用 `Some` 和 `None`。
*   那个 `<T>` 是个“泛型类型参数”（第10章会详细讲）。现在你只需要知道，`<T>` 意味着 `Some` 变体可以持有**任何类型**的一份数据。`T` 具体是什么类型，就会让整个 `Option<T>` 成为一个不同的具体类型。
    *   例如：
        ```rust
        let some_number = Some(5);         // some_number 的类型是 Option<i32> (因为 5 是 i32)
        let some_char = Some('e');         // some_char 的类型是 Option<char> (因为 'e' 是 char)

        let absent_number: Option<i32> = None; // absent_number 是 Option<i32> 类型，但它现在是 None
                                            // 对于 None，我们需要显式告诉 Rust 它应该是什么 Option 类型，
                                            // 因为光看 None，编译器猜不出 Some 的话会是什么类型。
        ```

**为啥 `Option<T>` 比 `null` 好？**

简单说，因为 **`Option<T>` 和 `T` （比如 `Option<i32>` 和 `i32`）是不同的类型**！
编译器不让你把一个 `Option<T>` 类型的值，想当然地当成一个肯定有效的 `T` 类型的值来用。

比如，下面这段代码编译不过，因为它想把一个 `i8` 和一个 `Option<i8>` 相加：

```rust
// 这段代码编译不通过！
let x: i8 = 5;
let y: Option<i8> = Some(5);

// let sum = x + y; // 错误！不能把 i8 和 Option<i8> 直接加起来
```
编译器会报错，大概意思是说：“我不知道怎么把一个 `i8` 和一个 `Option<i8>` 加起来，因为它们类型不一样啊！”

**这就牛逼了！**
*   在 Rust 里，如果一个值的类型是 `i8` (或者其他任何不是 `Option` 的类型)，编译器保证你拿到的肯定是个有效的值。你可以放心大胆地用，不用先检查它是不是 `null`。
*   只有当你的值是 `Option<i8>` （或类似的 `Option<T>`）类型时，你才需要担心它“可能没有值”（是 `None` 的情况）。而且，编译器会**强制**你在使用这个值之前，必须处理好 `None` 这种可能性。

换句话说，**你必须把一个 `Option<T>` 转换成 `T`，然后才能对它进行 `T` 类型的操作。**
这通常能抓住 `null` 最常见的问题之一：想当然地以为某个东西不是 `null`，结果它偏偏就是 `null`。

*   通过消除这种“错误地假设值非空”的风险，你的代码会更健壮。
*   要想让一个值可能是“空的”（`null` 的等价概念），你必须明确地使用 `Option<T>` 类型。
*   然后，当你使用这个值时，你被要求明确地处理值是“空的”（即 `None`）的情况。
*   只要一个值的类型不是 `Option<T>`，你就可以安全地假设它不是“空的”。这是 Rust 的一个刻意设计，为了限制 `null` 的泛滥，提高 Rust 代码的安全性。

**那么，怎么从 `Some` 变体里把那个 `T` 值取出来用呢？**
`Option<T>` 枚举有很多有用的方法，可以应对各种情况（你可以查阅它的文档）。熟悉这些方法对你用好 Rust 非常重要。

总的来说，要使用一个 `Option<T>` 值，你就需要有代码来分别处理它的每个变体：
*   一些代码，只在值是 `Some(T)` 的时候运行，并且这段代码可以使用里面的那个 `T`。
*   另一些代码，只在值是 `None` 的时候运行，这段代码自然拿不到 `T` 值。

后面要讲的 `match` 表达式就是一种控制流程的结构，当它和枚举一起用的时候，就能做到这一点：它会根据枚举具体是哪个变体来运行不同的代码，并且那段代码可以使用匹配到的值里面的数据。

明白了吗？这一大段主要就是解释了：
1.  枚举是啥，怎么定义。
2.  枚举的变体可以带数据，而且每个变体带的数据类型和数量可以不一样，这比结构体灵活。
3.  `Option<T>` 是个超级重要的枚举，用来表示“可能有值”或“可能没值”，是 Rust 对付 `null` 问题的法宝，能让代码更安全。
4.  要使用 `Option<T>` 里的值，你必须处理 `Some` 和 `None` 两种情况，编译器会帮你把关。