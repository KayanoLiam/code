# 函数 (Functions)
好的，咱们现在来聊聊**函数 (Functions)**，这是组织代码、让代码可重用的一种基本方式。

**函数：代码的“小包裹”**

想象一下，你有一堆需要按顺序执行的指令（代码行）。你可以把这些相关的指令打包在一起，给这个“包裹”起个名字，这就成了一个**函数**。

*   **定义函数:** 用 `fn` 关键字，后面跟函数名，一对圆括号 `()`（里面可以放参数，后面说），然后用大括号 `{}` 把函数体（指令）包起来。
*   **调用函数:** 在需要执行这些指令的地方，写上函数名和一对圆括号 `()`。

**`main` 函数：特殊的入口**

我们一直写的 `main` 函数就是一个非常特殊的函数，它是整个程序的**入口点**，程序总是从 `main` 函数的第一行开始执行。

**函数命名规范：蛇形命名法 (Snake Case)**

Rust 的习惯是，给函数和变量起名字时，使用 **snake_case** 风格：所有字母小写，单词之间用下划线 `_` 分隔。比如 `calculate_sum`, `print_user_name`。

**看个例子：定义和调用函数**

```rust
// Filename: src/main.rs

fn main() { // main 函数定义
    println!("Hello, world!"); // main 函数的第一条指令

    another_function(); // 调用我们自己定义的 another_function 函数

    println!("回到 main 函数了");
}

// 定义我们自己的函数 another_function
fn another_function() {
    println!("这里是 another_function 内部。");
}
```

运行这段代码 (`cargo run`)，你会看到输出：

```
Hello, world!
这里是 another_function 内部。
回到 main 函数了
```

**发生了什么？**
1.  程序从 `main` 函数开始。
2.  打印 "Hello, world!"。
3.  遇到 `another_function();`，程序**跳转**到 `another_function` 函数的定义处，开始执行里面的代码。
4.  `another_function` 打印 "这里是 another_function 内部。"。
5.  `another_function` 执行完毕，程序**返回**到 `main` 函数里调用它的地方的下一行。
6.  打印 "回到 main 函数了"。

**定义顺序不重要：** 你可以在 `main` 函数**之前**或**之后**定义 `another_function`，Rust 不在乎。只要编译器能找到这个函数的定义（在同一个文件里，或者通过 `use` 导入），就能调用它。

**函数参数 (Parameters)：给函数传递信息**

有时候，我们希望函数能根据不同的输入值，做出不同的行为。这时就需要给函数定义**参数**。参数就像是函数内部专用的变量，它的值由调用函数时提供。

*   **定义带参数的函数:** 在函数名后面的圆括号 `()` 里声明参数，**必须**为每个参数指定**名字**和**类型**。
*   **调用带参数的函数:** 在调用函数时，在圆括号 `()` 里提供具体的**值**，这些值叫做**参数 (arguments)**（虽然日常口语里，“参数 parameter” 和 “参数 argument” 经常混用）。

看例子：

```rust
// Filename: src/main.rs

fn main() {
    print_a_number(5); // 调用函数，传入参数值 5
    print_a_number(100); // 再次调用，传入不同的值
}

// 定义一个接收 i32 类型参数的函数
fn print_a_number(x: i32) { // 参数名叫 x，类型是 i32
    println!("传入的数字是: {x}"); // 使用参数 x
}
```

运行结果：

```
传入的数字是: 5
传入的数字是: 100
```

**必须指定参数类型！**
在 Rust 函数定义里，**必须**给每个参数写清楚它的类型（比如 `x: i32`）。这是 Rust 的设计选择，有助于编译器检查错误，也让代码更清晰。编译器知道了函数期望什么类型的参数，就能在你调用函数传错类型时给出明确的错误提示。

**多个参数：** 用逗号 `,` 分隔。

```rust
// Filename: src/main.rs

fn main() {
    print_labeled_measurement(5, 'h'); // 传入两个参数
}

// 定义接收两个参数的函数
fn print_labeled_measurement(value: i32, unit_label: char) { // 参数 value 是 i32, unit_label 是 char
    println!("测量值是: {value}{unit_label}");
}
```

运行结果：

```
测量值是: 5h
```

**语句 (Statements) vs. 表达式 (Expressions)：Rust 的核心区别**

理解这个区别对掌握 Rust 很重要。

*   **语句 (Statements):** 执行某个动作，**不**产生（返回）一个值。
    *   大部分以分号 `;` 结尾的代码行都是语句。
    *   比如：`let y = 6;` 这是一条创建变量的语句。`println!(...)`; 这是一条打印的语句。
    *   函数定义 `fn main() { ... }` 本身也是一条语句。
    *   **关键：** 语句没有返回值。你不能把一条 `let` 语句赋值给另一个变量，比如 `let x = (let y = 6);` 是错误的，因为 `let y = 6` 不产生值。
*   **表达式 (Expressions):** 计算并**产生**一个值。
    *   大部分你会写的代码其实都是表达式。
    *   比如：`5 + 6` 是一个表达式，它的值是 `11`。`6` (在 `let y = 6;` 里) 本身也是一个表达式，值是 `6`。
    *   **调用函数** 是一个表达式 (它的值是函数的返回值)。
    *   **调用宏** (`println!` 虽然看起来像函数调用，但它是宏) 也是一个表达式。
    *   用大括号 `{}` 创建的**新的代码块 (block)** 也是一个表达式！

看个代码块作为表达式的例子：

```rust
// Filename: src/main.rs
fn main() {
    let y = { // y 被绑定到后面代码块的值
        let x = 3;
        x + 1 // 注意！这行末尾没有分号！
    }; // 代码块结束

    println!("y 的值是: {y}"); // 输出 y 的值是: 4
}
```

这个 `{ let x = 3; x + 1 }` 代码块做了两件事：
1.  创建了一个局部变量 `x` 并赋值为 3。
2.  计算 `x + 1`，结果是 4。
因为 `x + 1` 是这个代码块里的**最后一行**，并且它**没有**以分号结尾，所以这个表达式的值 `4` 就成了整个代码块的值。然后这个值 `4` 被赋给了变量 `y`。

**关键点：表达式后面不加分号，它才会有值！** 如果你给 `x + 1` 加上分号变成 `x + 1;`，它就从一个表达式变成了一个语句，这个语句不返回值（或者说返回 `()` 单元类型），那么整个代码块的值就是 `()`，而不是 `4` 了。这在函数返回值时特别重要！

**函数返回值 (Return Values)**

函数可以把计算结果返回给调用它的代码。

*   **声明返回类型：** 在函数参数列表的圆括号 `()` 后面，使用箭头 `->` 加上返回值的类型。比如 `fn five() -> i32 { ... }` 表示这个函数返回一个 `i32` 类型的值。
*   **返回值是什么？** 在 Rust 里，函数体中**最后一个表达式的值**会自动成为函数的返回值。**这个最后的表达式不能带分号！**

看例子：

```rust
// Filename: src/main.rs

// 定义一个返回 i32 类型值的函数
fn five() -> i32 {
    5 // 函数体只有 5 这个表达式，它没有分号，所以 5 就是返回值
}

fn main() {
    let x = five(); // 调用 five()，把返回值赋给 x
    println!("x 的值是: {x}"); // 输出 x 的值是: 5
}
```

再看一个带参数和计算的例子：

```rust
// Filename: src/main.rs

fn main() {
    let x = plus_one(5); // 调用 plus_one(5)，期望返回 6
    println!("x 的值是: {x}"); // 输出 x 的值是: 6
}

// 定义一个接收 i32，返回 i32 的函数
fn plus_one(x: i32) -> i32 {
    x + 1 // 这是函数体最后一个表达式，没有分号，它的值 (x+1) 就是返回值
}
```

**如果给最后一个表达式加上分号会怎样？**

```rust
// 这段代码编译不过！
fn plus_one_broken(x: i32) -> i32 {
    x + 1; // <-- 注意这里加了分号！
}
// fn main() { let x = plus_one_broken(5); }
```

编译器会报错：`mismatched types` (类型不匹配)。
错误信息会说：函数签名说要返回 `i32`，但你函数体最后是个语句 (`x + 1;`)，语句不返回值（返回的是 `()` 单元类型），所以类型冲突了！编译器还会很贴心地提示你：“去掉那个分号试试？” (`help: remove this semicolon`)。

**提前返回：`return` 关键字**

虽然大部分函数通过隐式返回最后一个表达式的值就够了，但你也可以在函数体**任何地方**使用 `return` 关键字来**立即**结束函数执行并返回一个值。

```rust
fn find_first_even(numbers: &[i32]) -> Option<i32> { // 返回 Option<i32>
    for &num in numbers {
        if num % 2 == 0 {
            return Some(num); // 找到第一个偶数，立刻返回 Some(它)
        }
    }
    None // 如果循环结束都没找到，返回 None
}
```
在这个例子里，一旦找到偶数，就用 `return Some(num);` 直接返回了，不会再继续循环。如果循环正常结束（没找到偶数），函数最后隐式返回 `None`。

**总结一下函数：**

*   用 `fn` 定义，用 `函数名()` 调用。
*   命名用 `snake_case`。
*   参数在 `()` 里定义，**必须**指定类型。
*   函数体由一系列**语句**（通常带分号，不返回值）和一个可选的**结尾表达式**（不带分号，其值作为函数返回值）组成。
*   用 `-> 返回类型` 声明函数的返回值类型。
*   默认返回最后一个表达式的值（无分号）。
*   可以用 `return` 关键字从函数任何地方提前返回值。
*   理解**语句**和**表达式**的区别非常重要，特别是结尾的分号会把表达式变成语句，从而影响返回值。