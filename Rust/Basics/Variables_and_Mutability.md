# 变量和可变性 (Variables and Mutability)
深入聊聊 Rust 里的**变量 (Variables)** 和一个非常重要的概念：**可变性 (Mutability)**。

**默认不可变：Rust 的“安全带”**

回忆一下我们之前猜数字游戏里用 `let` 创建变量。在 Rust 里，当你像下面这样写：

```rust
let x = 5;
```

这个变量 `x` **默认是不可变的 (immutable)**。什么意思呢？就是一旦你把 `5` 这个值绑定（“粘”）到 `x` 这个名字上之后，你就**不能**再给 `x` 赋一个新值了。

不信？咱们来试试。创建一个新项目 `cargo new variables`，然后修改 `src/main.rs`：

```rust
// Filename: src/main.rs
// 这段代码编译不过！
fn main() {
    let x = 5; // 把 5 绑定给 x
    println!("x 的值是: {x}");
    x = 6; // 尝试把 6 重新绑定给 x
    println!("x 的值是: {x}");
}
```

运行 `cargo run`，你会看到编译器报错：

```
error[E0384]: cannot assign twice to immutable variable `x`
 --> src/main.rs:4:5
  |
2 |     let x = 5;
  |         - first assignment to `x` (第一次赋值在这里)
3 |     println!("The value of x is: {x}");
4 |     x = 6;
  |     ^^^^^ cannot assign twice to immutable variable (不能对不可变变量二次赋值)
```

编译器直接指出了问题：你试图给一个**不可变**的变量 `x` 赋第二个值。

**为什么 Rust 要默认不可变？**

这可能和你习惯的其他语言（比如 Python, JavaScript）不太一样，那些语言的变量通常默认是可变的。Rust 这样做是故意的，这是它强调**安全**和**并发**（多任务同时进行）设计哲学的一部分。

想象一下，如果一个值在程序的某个地方被假定是永远不变的，但程序的另一个地方（可能是在另一个线程里）却悄悄改变了它，这很容易导致难以发现的 Bug。默认不可变可以：

1.  **减少意外修改：** 降低了因为不小心改了不该改的值而引入 Bug 的风险。
2.  **更容易推理代码：** 当你看到 `let x = 5;` 时，你可以很确定在它的作用域内，`x` 的值不会变（除非被遮蔽，后面会讲），这让理解代码逻辑更简单。
3.  **有助于并发：** 不可变的数据在多个线程之间共享通常是安全的，不需要复杂的加锁机制。

Rust 这是在用一种温和的方式“推动”你写出更安全、更可靠的代码。

**需要改变？那就明确说出来：`mut`**

当然，很多时候我们确实需要改变变量的值（比如猜数字游戏里要更新用户的猜测次数，或者累加一个总和）。Rust 当然也允许这样做，但你需要**明确地**告诉编译器：“这个变量，我是打算后面要改它的值的！”

怎么告诉编译器呢？就是在 `let` 后面，变量名前面，加上 `mut` 关键字，就像我们在猜数字游戏里用 `let mut guess = String::new();` 一样。

我们把刚才报错的代码改一下：

```rust
// Filename: src/main.rs
fn main() {
    let mut x = 5; // 加上 mut，表示 x 是可变的
    println!("x 的值是: {x}");
    x = 6; // 现在可以给 x 赋新值了！
    println!("x 的值是: {x}");
}
```

再运行 `cargo run`：

```bash
$ cargo run
   Compiling variables v0.1.0 (...)
    Finished dev [unoptimized + debuginfo] target(s) in ...s
     Running `target/debug/variables`
x 的值是: 5
x 的值是: 6
```

成功了！加上 `mut` 后，我们就可以修改 `x` 绑定的值了。

使用 `mut` 不仅仅是为了让代码能编译通过，它也是一种**沟通**：它告诉后来看你代码的人（包括未来的你自己）：“注意了，这个变量的值在后面可能会变。”

**那么，什么时候用 `mut` 什么时候不用呢？**

这是个人选择和具体情况的问题。总的原则是：**如果一个变量的值不需要改变，就让它保持不可变。只有当你确实需要改变它的时候，才加上 `mut`。** 优先选择不可变是 Rust 的推荐做法。

**常量 (Constants)：永远不变的值**

除了变量，Rust 还有**常量 (constants)** 的概念。常量和不可变变量有点像，它们的值都不能改变，但有几个关键区别：

1.  **永远不可变:** 常量**不能**使用 `mut`。它们天生就是，并且永远是不可变的。不可变变量只是“默认”不可变，你可以选择用 `mut` 让它可变。
2.  **声明关键字:** 声明常量用 `const` 关键字，而不是 `let`。
3.  **必须注明类型:** 声明常量时，**必须**明确写出它的类型（比如 `: u32`）。对于 `let` 声明的变量，Rust 通常能自动推断类型，但 `const` 不行。
4.  **作用域:** 常量可以在任何作用域声明，包括**全局作用域**（在所有函数之外）。这使得它们很适合定义一些全局都需要知道的固定值。
5.  **值必须是编译期常量:** 常量的值必须在**编译时**就能确定下来，不能是运行时才能计算出的结果。你可以用一些简单的表达式，比如算术运算，但不能调用需要在运行时才能执行的函数。

看个例子：

```rust
// 在全局作用域声明一个常量
const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3; // 必须指定类型 u32

fn main() {
    println!("三小时有多少秒？ {}", THREE_HOURS_IN_SECONDS);
    // THREE_HOURS_IN_SECONDS = 10; // 错误！不能修改常量
}
```

*   **命名规范：** 常量的名字习惯上用**全大写**，单词之间用下划线 `_` 分隔（比如 `MAX_POINTS`）。
*   **用途：** 常量非常适合定义一些在程序中多处使用、意义明确且不会改变的值，比如游戏里的最高分、物理常数（光速）、或者一些配置参数。把这些“魔法数字”或硬编码的值定义成常量，能让代码更易读、易维护。如果将来这个值需要修改（比如最高分规则变了），只需要改常量定义这一处地方就行了。

**遮蔽 (Shadowing)：给变量“换个身份”**

还记得猜数字游戏里我们遇到的情况吗？

```rust
let mut guess = String::new();
// ... read user input into guess (String) ...
let guess: u32 = guess.trim().parse().expect("..."); // <- 这里！
```

我们用 `let guess: u32 = ...` 再次声明了一个名为 `guess` 的变量。这并不是修改了原来那个字符串 `guess` 的类型，而是创建了一个**全新的**变量，它恰好也叫 `guess`，并且类型是 `u32`。这个新的 `u32` 类型的 `guess` 把旧的 `String` 类型的 `guess` 给**“遮蔽” (shadow)** 了。

从这一行代码开始，直到这个新的 `guess` 离开它的作用域（或者被再次遮蔽），当你在代码里写 `guess` 时，指的就是这个 `u32` 类型的新变量了。

**遮蔽的特点和用途：**

1.  **重复使用 `let`:** 遮蔽是通过再次使用 `let` 关键字和相同的变量名来实现的。
2.  **可以改变类型:** 这是遮蔽和 `mut` 的一个**核心区别**。因为每次 `let` 都是创建一个新变量，所以你可以改变值的类型。比如从字符串变成数字：
    ```rust
    let spaces = "   "; // spaces 是 &str 类型
    let spaces = spaces.len(); // 新的 spaces 是 usize 类型 (长度)
    ```
    如果你试图用 `mut` 来做这件事，会编译失败，因为 `mut` 只能改变**同一个**变量的值，不能改变它的类型：
    ```rust
    let mut spaces = "   ";
    spaces = spaces.len(); // 错误! 不能把 usize 赋给 &str 类型的变量
    ```
3.  **方便性:** 遮蔽允许你对一个值进行一系列转换，但每次转换后仍然使用同一个简洁的名字，而不需要想出像 `spaces_str`, `spaces_len` 这样不同的名字。
4.  **作用域:** 遮蔽也受作用域限制。在一个内部作用域里遮蔽一个变量，当离开这个作用域后，外部的同名变量会重新“显现”出来。

看个作用域的例子：

```rust
fn main() {
    let x = 5; // 外部 x 是 5

    let x = x + 1; // 外部 x 被遮蔽，新 x 是 6

    { // 进入内部作用域
        let x = x * 2; // 内部 x 遮蔽外部 x，新 x 是 12
        println!("内部作用域的 x 是: {x}"); // 输出 12
    } // 离开内部作用域

    // 内部的遮蔽结束了，x 回到了它在这个作用域最后的值
    println!("外部作用域的 x 是: {x}"); // 输出 6
}
```

**总结一下变量和可变性：**

*   **默认不可变 (`let x = ...`):** Rust 推荐的做法，更安全，易推理。
*   **需要可变 (`let mut x = ...`):** 当你确实需要改变变量的值时，明确使用 `mut`。
*   **常量 (`const NAME: TYPE = ...`):** 用于编译时就确定、全局固定不变的值，必须指定类型，全大写命名。
*   **遮蔽 (`let x = ...; let x = ...;`):** 用 `let` 重复声明同名变量，可以改变类型，方便进行值转换。它创建新变量，不是修改旧变量。

理解变量的可变性、常量和遮蔽，是掌握 Rust 基础的关键一步。接下来可以学习更多关于数据类型的内容了。