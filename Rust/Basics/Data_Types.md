# 数据类型 (Data Types)
聊聊 Rust 里的**数据类型 (Data Types)**。

**核心概念：类型告诉 Rust 这是啥**

想象一下你要处理一堆东西，有数字、有文字、有对错判断。你得告诉 Rust 每个东西是“什么种类”的，它才知道怎么操作这些东西。比如，数字可以加减乘除，文字可以拼接，但你不能拿文字去做乘法。**数据类型**就是给值的“种类”或“身份”的标签。

**静态类型语言 (Statically Typed)**

Rust 是一种**静态类型**语言。这意味着**在程序运行之前（也就是编译的时候）**，Rust 编译器**必须**知道你程序里**所有变量**的类型是什么。

*   **类型推断 (Type Inference):** 大多数时候，Rust 很聪明。你写 `let x = 5;`，它看到 `5` 是个整数，就能**推断**出 `x` 应该是整数类型（默认是 `i32`）。你写 `let name = "Alice";`，它看到 `"Alice"` 是个字符串，就能推断出 `name` 的类型。
*   **需要类型注解 (Type Annotation):** 但有时候，Rust 自己也搞不清楚你到底想要哪种类型。最常见的情况就是我们之前猜数字游戏里的 `parse()` 方法：

    ```rust
    let guess: u32 = "42".parse().expect("Not a number!");
    //         ^^^^^ 这个 : u32 就是类型注解
    ```
    字符串 `"42"` 可以被解析成很多种数字类型（`i32`, `u32`, `i64`, `f32` 等等）。如果你不写 `: u32`，编译器就懵了，不知道你到底想要哪种，它就会报错，提示“需要类型注解 (type annotations needed)”。这时候，你就必须用冒号 `:` 加上明确的类型（比如 `u32`）来告诉编译器你的意图。

**两大类数据类型：**

Rust 的数据类型主要可以分成两大类：

1.  **标量类型 (Scalar Types):** 代表**单个**值。
2.  **复合类型 (Compound Types):** 可以把**多个**值组合成一个类型。

咱们先来看标量类型。

**标量类型 (Scalar Types)**

Rust 有四种主要的标量类型：

1.  **整数 (Integers):** 没有小数部分的数字。
    *   **分类：**
        *   **有符号 (Signed):** 以 `i` 开头（比如 `i8`, `i16`, `i32`, `i64`, `i128`）。可以表示正数、负数和零。数字表示位数（8位、16位等）。
        *   **无符号 (Unsigned):** 以 `u` 开头（比如 `u8`, `u16`, `u32`, `u64`, `u128`）。只能表示正数和零。
        *   **架构相关:** `isize` 和 `usize`。它们的大小取决于你的电脑是 32 位还是 64 位架构。主要用于索引集合（比如数组、向量）的大小或下标。
    *   **范围：** 位数越多，能表示的数字范围越大。
        *   有符号 `iN`: 范围是 `-(2^(N-1))` 到 `2^(N-1) - 1`。比如 `i8` 是 -128 到 127。
        *   无符号 `uN`: 范围是 `0` 到 `2^N - 1`。比如 `u8` 是 0 到 255。
    *   **默认类型：** 如果你不指定整数类型，Rust 默认是 `i32`。这通常是个不错的起点。
    *   **字面量 (Literals):** 你可以写不同进制的整数：
        *   十进制：`98_222` (下划线 `_` 可以用作视觉分隔符，方便阅读，没实际意义)
        *   十六进制：`0xff` (以 `0x` 开头)
        *   八进制：`0o77` (以 `0o` 开头)
        *   二进制：`0b1111_0000` (以 `0b` 开头)
        *   字节 (仅 `u8`): `b'A'` (表示字符 'A' 的 ASCII 码值，即 65)
    *   **类型后缀：** 如果一个数字字面量可能有多种类型，你可以加后缀指定，比如 `57u8` 表示这是一个 `u8` 类型的 57。
    *   **整数溢出 (Integer Overflow):**
        *   当你试图给一个整数变量赋一个超出它表示范围的值时（比如给 `u8` 类型的变量赋值 256），就会发生溢出。
        *   **Debug 模式 (默认 `cargo run`):** Rust 会检查溢出，并在发生溢出时让程序**崩溃 (panic!)**。这是为了帮你尽早发现问题。
        *   **Release 模式 (`cargo run --release`):** 为了性能，Rust **不**检查溢出。发生溢出时，它会进行“**二进制补码环绕 (two's complement wrapping)**”。简单说就是“转圈圈”：`u8` 类型的 256 会变成 0，257 变成 1；`i8` 类型的 128 会变成 -128。**依赖这种环绕行为通常是错误的**，因为它很可能不是你想要的结果。
        *   **显式处理溢出：** 如果你预期可能发生溢出并想控制它，标准库为数字类型提供了一些方法：
            *   `wrapping_*` 方法 (如 `wrapping_add`): 总是进行环绕，不 panic。
            *   `checked_*` 方法: 如果溢出，返回 `None` (表示失败)，否则返回 `Some(结果)`。
            *   `overflowing_*` 方法: 返回一个包含结果和是否溢出布尔值的元组。
            *   `saturating_*` 方法: 如果溢出，结果就“饱和”停留在类型的最大值或最小值。

2.  **浮点数 (Floating-Point Numbers):** 带小数点的数字。
    *   **类型：** `f32` (32位，单精度) 和 `f64` (64位，双精度)。
    *   **默认类型：** `f64`。因为现代 CPU 处理 `f64` 和 `f32` 速度差不多，但 `f64` 精度更高。
    *   **表示标准：** 遵循 IEEE-754 标准。
    *   **都是有符号的。**
    *   **例子：**
        ```rust
        let x = 2.0; // Rust 推断为 f64 (默认)
        let y: f32 = 3.0; // 显式指定为 f32
        ```

3.  **布尔值 (Booleans):** 只有两种可能的值：`true` (真) 和 `false` (假)。
    *   **类型：** `bool`。
    *   **大小：** 占 1 个字节。
    *   **用途：** 主要用于条件判断，比如 `if` 语句。
    *   **例子：**
        ```rust
        let t = true;
        let f: bool = false; // 显式指定类型
        ```

4.  **字符 (Characters):** 表示单个字母、数字、符号，甚至 Emoji。
    *   **类型：** `char`。
    *   **字面量：** 用**单引号** `'` 包裹，比如 `'z'`, `'😻'`, `'中'`。**注意和双引号 `"` 包裹的字符串区别开！**
    *   **大小：** 占 4 个字节。
    *   **表示：** 代表一个 **Unicode 标量值 (Unicode Scalar Value)**。这意味着 `char` 能表示的远不止 ASCII 字符，它可以表示世界上几乎所有的字符，包括带重音的字母、中日韩文字、Emoji 等。
    *   **例子：**
        ```rust
        let c = 'z';
        let z: char = 'ℤ'; // 显式指定类型
        let heart_eyed_cat = '😻';
        ```

**数值运算 (Numeric Operations)**

Rust 支持所有你期望的基本数学运算：

*   加法: `+`
*   减法: `-`
*   乘法: `*`
*   除法: `/`
    *   **整数除法：** 会向零截断（舍弃小数部分）。比如 `5 / 2` 结果是 `2`，`-5 / 3` 结果是 `-1`。
*   求余 (取模): `%`

```rust
fn main() {
    let sum = 5 + 10;          // 15
    let difference = 95.5 - 4.3; // 91.2
    let product = 4 * 30;       // 120
    let quotient = 56.7 / 32.2; // 1.76...
    let truncated = -5 / 3;    // -1 (整数除法截断)
    let remainder = 43 % 5;      // 3   (43 = 5 * 8 + 3)
}
```

**复合类型 (Compound Types)**

复合类型可以把多个值组合在一起。Rust 有两种基本的复合类型：

1.  **元组 (Tuple):**
    *   **作用：** 把**不同类型**的值组合成一个固定的集合。
    *   **特点：**
        *   **固定长度：** 一旦声明，长度不能改变。
        *   **类型可不同：** 元组里的每个元素可以有不同的类型。
    *   **创建：** 用圆括号 `()` 把逗号分隔的值包起来。
        ```rust
        let tup: (i32, f64, u8) = (500, 6.4, 1); // 可以加类型注解
        let tup2 = ("Alice", 30); // 类型推断为 (&str, i32)
        ```
    *   **访问元素：**
        *   **解构 (Destructuring):** 用 `let` 和模式匹配把元组拆开赋给变量。
          ```rust
          let (x, y, z) = tup; // x=500, y=6.4, z=1
          println!("The value of y is: {y}"); // 输出 6.4
          ```
        *   **点号 + 索引:** 用点号 `.` 后面跟元素的**索引**（从 0 开始）来访问。
          ```rust
          let five_hundred = tup.0; // 500
          let six_point_four = tup.1; // 6.4
          let one = tup.2; // 1
          ```
    *   **单元类型 (Unit Type):** 一个没有任何值的空元组 `()`。它既是一个值，也是一个类型。如果一个函数或表达式不显式返回任何值，它就隐式地返回单元值 `()`。

2.  **数组 (Array):**
    *   **作用：** 把**相同类型**的值组合成一个固定的集合。
    *   **特点：**
        *   **固定长度：** 一旦声明，长度不能改变。
        *   **类型必须相同：** 数组里的所有元素必须是同一种类型。
        *   **内存分配：** 数组是一整块连续的内存，通常分配在**栈 (Stack)** 上（后面章节会详细讲栈和堆），访问速度快。
    *   **创建：** 用方括号 `[]` 把逗号分隔的值包起来。
        ```rust
        let a = [1, 2, 3, 4, 5]; // 类型推断为 [i32; 5]
        let months = ["January", "February", /*...*/ "December"]; // [&str; 12]
        ```
    *   **带类型和长度的注解：** `let a: [i32; 5] = [1, 2, 3, 4, 5];` 类型是 `[元素类型; 长度]`。
    *   **快速初始化相同值:** `let a = [3; 5];` 这等价于 `let a = [3, 3, 3, 3, 3];`。
    *   **访问元素：** 使用方括号 `[]` 和**索引**（从 0 开始）来访问。
        ```rust
        let first = a[0]; // 1
        let second = a[1]; // 2
        ```
    *   **数组 vs. 向量 (Vector):** 数组长度固定。如果你需要一个长度可以动态增长或缩小的集合，应该使用标准库提供的**向量 (`Vec<T>`)**。向量更灵活，是更常用的集合类型。但如果你确定元素数量不变，数组因为在栈上分配且大小固定，可能效率稍高。
    *   **访问越界 (Invalid Access):**
        *   如果你试图访问一个超出数组边界的索引（比如数组长度是 5，你访问 `a[10]`），Rust 会在**运行时**进行检查。
        *   如果发现索引无效，程序会**立即崩溃 (panic!)** 并报错 "index out of bounds"。
        *   这是 Rust **内存安全**的重要保证！它防止你访问到无效的内存区域，避免了很多其他语言中可能出现的难以调试的错误或安全漏洞。

**总结一下数据类型：**

*   Rust 是**静态类型**语言，编译时必须知道所有类型，但常常能**自动推断**。必要时需加**类型注解** (`: Type`)。
*   **标量类型（单个值）：**
    *   **整数 (`i/u` + 位数, `isize/usize`):** 注意符号、范围、溢出行为。
    *   **浮点数 (`f32`, `f64`):** 默认 `f64`。
    *   **布尔值 (`bool`):** `true` 或 `false`。
    *   **字符 (`char`):** 单引号，Unicode 标量值，4 字节。
*   **复合类型（多个值）：**
    *   **元组 `(T, U, ...)`:** 固定长度，类型可不同，用解构或 `.索引` 访问。
    *   **数组 `[T; N]`:** 固定长度，类型必须相同，用 `[索引]` 访问，有运行时边界检查保证内存安全。

理解这些基本的数据类型是编写任何 Rust 程序的基础。